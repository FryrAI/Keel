# Spec 009: Tool Integration — LLM Tool Hooks, Instructions, and CI

```yaml
tags: [keel, spec, tool-integration, hooks, instructions, ci]
owner: Agent C (Surface)
dependencies:
  - "[[keel-speckit/006-enforcement-engine/spec|Spec 006: Enforcement Engine]]"
  - "[[keel-speckit/008-output-formats/spec|Spec 008: Output Formats]]"
prd_sections: [9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8, 9.9, 9.10, 9.11, 9.12, 9.13, 9.14, 9.15, 9.16]
priority: P0 — keel's value depends on integration with LLM coding tools
```

## Summary

This spec defines how keel integrates with every supported LLM coding tool: hook configurations for Tier 1 enforced tools (Claude Code, Cursor, Gemini CLI, Windsurf, Letta Code), instruction files for Tier 2 cooperative tools (GitHub Copilot, Codex, Antigravity, Aider), the shared instruction template, the post-edit hook script, the pre-commit git hook, CI templates, tool auto-detection, config merge strategy, and the backpressure flow. Agents never read the PRD — this spec restates all relevant PRD content in full.

---

## PRD Traceability

| PRD Section | Content Extracted |
|-------------|-------------------|
| 9.1 | Universal CLI interface — every tool can call keel via shell commands |
| 9.2 | Integration matrix — Tier 1 (enforced) vs Tier 2 (cooperative) classification |
| 9.3 | Claude Code hook config (`.claude/settings.json`), post-edit hook script |
| 9.4 | Codex CLI (`AGENTS.md`) cooperative integration |
| 9.5 | Cursor hook config (`.cursor/hooks.json`, `.cursor/rules/keel.mdc`) |
| 9.6 | Google Antigravity (`.agent/rules/keel.md`, `.agent/skills/keel/SKILL.md`) |
| 9.7 | Gemini CLI hook config (`.gemini/settings.json`), AfterAgent self-correction loop |
| 9.8 | Windsurf hook config (`.windsurf/hooks.json`), PreToolUse note |
| 9.9 | Aider (`.aider.conf.yml`), map-tokens/map-refresh config |
| 9.10 | Letta Code hook config, ~12 events, exit-code-2 blocking |
| 9.11 | GitHub Copilot MCP policies, `.github/copilot-instructions.md` |
| 9.12 | Shared instruction template (full text) |
| 9.13 | Backpressure flow for Tier 1 and Tier 2 tools, enforcement layers |
| 9.14 | MCP server (`keel serve`) — transport only, see Spec 010 for full spec |
| 9.15 | VS Code extension — see Spec 011 for full spec |
| 9.16 | CI integration (GitHub Actions, GitLab CI templates) |

---

## Dependencies

- **[[keel-speckit/006-enforcement-engine/spec|Spec 006: Enforcement Engine]]** — hooks trigger enforcement via `keel compile`
- **[[keel-speckit/008-output-formats/spec|Spec 008: Output Formats]]** — hooks consume JSON output from `keel compile`

---

## Integration Matrix

| Tool | Instruction File | Hooks (Enforced) | Hook Config Format | Session Context Injection | Post-Edit Validation |
|------|-----------------|------------------|--------------------|--------------------------|---------------------|
| **Claude Code** | `CLAUDE.md` | Tier 1: 14 event types, 3 handler types (command/prompt/agent) | `.claude/settings.json` | SessionStart hook | Enforced (exit 2 blocks) |
| **Cursor** | `.cursor/rules/keel.mdc` | Tier 1: Full hooks since v1.7 (Oct 2025). 15+ events, exit 2 blocks | `.cursor/hooks.json` | SessionStart hook | Enforced (exit 2 blocks) |
| **Gemini CLI** | `GEMINI.md` | Tier 1: Full hooks since v0.26.0. 8 events, exit 2 blocks | `.gemini/settings.json` | SessionStart hook | Enforced (exit 2 blocks) |
| **Windsurf** | `.windsurfrules` | Tier 1: Cascade Hooks (late 2025). 11 events, exit 2 pre-hook blocks | `.windsurf/hooks.json` | SessionStart hook | Enforced (exit 2 blocks) |
| **Letta Code** | Letta instruction config | Tier 1: ~12 events, exit 2 blocks (same semantics as Claude Code) | Letta config | SessionStart hook | Enforced (exit 2 blocks) |
| **GitHub Copilot** | `.github/copilot-instructions.md` | Tier 2: MCP policies with JSON `permissionDecision: "deny"` (not exit-code-2) | Copilot settings / registry policies | Via custom instructions | Governance (MCP policy provider) |
| **Codex CLI** | `AGENTS.md` | Tier 2: `notify` only (no blocking). Top community request (#2109) | `.codex/config.toml` | Via AGENTS.md preamble | Cooperative (AGENTS.md instruction) |
| **Antigravity** | `.agent/rules/keel.md` + `.agent/skills/keel/SKILL.md` | Tier 2: No blocking hooks yet | -- | Via rule + skill | Cooperative (rule instruction) |
| **Aider** | `.aider.conf.yml` | Tier 2: No hook system | -- | Via `map-tokens`/`map-refresh` config | Cooperative (instruction) |

**Tier classification:**

- **Tier 1 (Enforced):** Claude Code, Cursor, Gemini CLI, Windsurf, Letta Code — full hook systems with exit-code-2 blocking
- **Tier 2 (Cooperative + Governance):** GitHub Copilot (MCP policies), Codex CLI, Antigravity, Aider — instruction/policy-based with git pre-commit catch-all

---

## Tier 1 Hook Configurations

### Claude Code

`.claude/settings.json` (generated by `keel init`):

```json
{
  "hooks": {
    "SessionStart": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "keel map --llm"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|MultiEdit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.keel/hooks/post-edit.sh"
          }
        ]
      }
    ]
  }
}
```

**SessionStart hook:** Injects the LLM-optimized map into Claude's context at the start of every session. Plain text stdout with exit code 0 -> added as context.

**PostToolUse hook:** After every Edit/Write/MultiEdit, runs `keel compile` on changed files. Exit code 2 -> stderr shown to Claude, must fix before proceeding.

**`CLAUDE.md`:** Appended between `<!-- keel:start -->` / `<!-- keel:end -->` markers using the shared instruction template (see below).

---

### Cursor

`.cursor/hooks.json` (generated by `keel init`):

```json
{
  "hooks": {
    "SessionStart": [
      {
        "command": "keel map --llm",
        "type": "command"
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write|MultiEdit",
        "command": "\"$PROJECT_DIR\"/.keel/hooks/post-edit.sh",
        "type": "command"
      }
    ]
  }
}
```

`.cursor/rules/keel.mdc` (supplementary instructions — hooks handle enforcement):

```markdown
---
description: keel code graph enforcement — structural validation for every edit
globs: ["**/*.ts", "**/*.tsx", "**/*.py", "**/*.go", "**/*.rs", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# keel — Code Graph Enforcement

This project uses keel (keel.engineer) for code graph enforcement.
Hooks handle automatic validation. Follow this workflow for proactive checks:

## Mandatory workflow:
1. Before editing a function with callers (↑ > 0), run: `keel discover <hash>`
2. After EVERY file edit, `keel compile` runs automatically via hooks
3. If errors returned, FIX THEM immediately
4. Type hints mandatory. Docstrings mandatory on public functions.
5. Check map before creating new functions. Place in correct module.

## Commands:
- `keel discover <hash>` — callers, callees, module context
- `keel compile <file>` — validate (auto-runs via hooks, can also run manually)
- `keel where <hash>` — resolve hash to file:line
```

**Known limitation (Cursor v2.0+):** The `agent_message` / `userMessage` field in hook responses is ignored in Cursor v2.0+. keel's blocking message may not be visible to the Cursor agent. Workaround: keel writes error context to `.keel/last-error.json` that the Cursor rules file instructs the agent to read after a block.

---

### Gemini CLI

`.gemini/settings.json` (generated by `keel init`):

```json
{
  "hooks": {
    "SessionStart": [
      {
        "command": "keel map --llm",
        "type": "command"
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "command": "\"$PROJECT_DIR\"/.keel/hooks/post-edit.sh",
        "type": "command"
      }
    ]
  }
}
```

`GEMINI.md` — supplementary instructions following the shared template.

**Gemini CLI unique feature — AfterAgent self-correction loop:** Gemini CLI's `AfterAgent` event with exit code 2 triggers an automatic retry turn — the agent self-corrects without user intervention. keel can use this to inspect code post-generation, reject it, and force the agent to fix it in a continuous loop until all contracts pass. This is architecturally superior to Claude Code's blocking model. keel should expose an `AfterAgent` hook in the generated `.gemini/settings.json`.

---

### Windsurf

`.windsurf/hooks.json` (generated by `keel init`):

```json
{
  "hooks": {
    "SessionStart": [
      {
        "command": "keel map --llm",
        "type": "command"
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "command": "\"$PROJECT_DIR\"/.keel/hooks/post-edit.sh",
        "type": "command"
      }
    ]
  }
}
```

**Note:** Windsurf uses `PreToolUse` (not `PostToolUse`) for blocking hooks. The hook script validates the previous edit on the next edit trigger. `.windsurfrules` file provides supplementary instructions.

---

### Letta Code

Letta Code has ~12 hook events with exit-code-2 blocking — the same semantics as Claude Code. `keel init` generates hook configuration when Letta is detected.

**Hook config:** keel registers as a hook provider in Letta's configuration, using the same `post-edit.sh` script shared across all Tier 1 tools. Events: `PreToolUse`, `PostToolUse`, `SessionStart`, `SessionEnd`, `PermissionRequest`, `Notification`, `Stop`, `SubagentStop`, `PreCompact`, `Setup`, and others.

**Instruction delivery:** Via Letta's instruction configuration, following the shared template.

---

## Tier 2 Instruction Files

### Codex CLI

`AGENTS.md` (generated by `keel init`):

```markdown
## keel — Code Graph Enforcement

<keel-map>
<!-- Auto-populated by: keel map --llm -->
<!-- Run `keel map --llm` to regenerate -->
</keel-map>

### Mandatory workflow:
1. Before editing a function with callers (↑ > 0 in the map above), run: `keel discover <hash>`
2. After EVERY file edit, run: `keel compile <file> --json`
3. If `keel compile` returns errors, FIX THEM before proceeding
4. Before creating a new function, check the map for existing similar functions
5. Place new functions in the module where they logically belong

### Commands:
- `keel discover <hash>` — callers, callees, module context
- `keel compile <file>` — validate changes (MUST run after every edit)
- `keel explain <error-code> <hash>` — inspect resolution reasoning
- `keel where <hash>` — resolve hash to file:line
- `keel map --llm` — regenerate map
```

---

### Google Antigravity

`.agent/rules/keel.md` (workspace rule — always active):

```markdown
# keel Code Graph Enforcement

This project uses keel. After EVERY file edit, run `keel compile <file> --json`.
Fix all errors before proceeding. Type hints and public docstrings are mandatory.
Before editing functions with upstream callers, run `keel discover <hash>`.
```

`.agent/skills/keel/SKILL.md` (skill — agent-triggered on code changes):

```markdown
---
name: keel-enforcement
description: Use this skill when editing code, creating new functions, or refactoring. Validates structural integrity via keel code graph enforcement.
---

# keel Code Graph Enforcement Skill

## When editing existing code:
1. Find the function hash from the keel map (run `keel map --llm` if not in context)
2. Run `keel discover <hash>` to see callers and callees
3. Make the edit
4. Run `keel compile <changed-file> --json`
5. Fix any errors before continuing

## When creating new functions:
1. Run `keel map --llm` and check if a similar function exists
2. Place in the module with the best semantic fit
3. Add type hints on all parameters and return type
4. Add docstring if the function is public
5. Run `keel compile <file> --json` to validate placement

## Commands:
- `keel discover <hash>` — show callers, callees, and module context
- `keel compile <file> --json` — validate changes
- `keel explain <error-code> <hash>` — inspect resolution reasoning
- `keel where <hash>` — resolve hash to file:line
- `keel map --llm` — token-optimized codebase map
```

---

### Aider

`.aider.conf.yml` (generated by `keel init`):

```yaml
# keel integration — cooperative enforcement
map-tokens: 2048
map-refresh: auto
```

**Important:** Aider uses `map-tokens` and `map-refresh` settings (NOT `map-file` — that option does not exist) for context injection. Instruction content follows the shared template, delivered via Aider's system prompt configuration.

---

### GitHub Copilot

`.github/copilot-instructions.md` (generated by `keel init` when Copilot is detected):

Integration approach: keel as MCP policy provider using Copilot's registry policies. keel exposes policy endpoints that Copilot queries before executing code modifications.

**Limitations:** JSON-based governance, not scriptable exit-code-2 hooks. keel cannot force Copilot to stop mid-generation. The git pre-commit hook remains the enforcement safety net for Copilot users.

---

## Shared Instruction Template

All instruction files share the same core content. `keel init` generates tool-specific wrappers around this template:

```markdown
## keel — Code Graph Enforcement

This project uses keel (keel.engineer) for code graph enforcement.

### Before editing a function:
- Before changing a function's **parameters, return type, or removing/renaming it**, run `keel discover <hash>` to understand what depends on it. The hash is shown in the keel map (injected at session start or embedded below).
- For **body-only changes** (bug fixes, refactoring internals, improving logging), skip discover — compile will catch any issues.
- If the function has upstream callers (↑ > 0), you MUST understand them before changing its interface.

### After every edit:
- Run `keel compile <file> --json` (automatic via hooks in Claude Code, manual in other tools)
- If it returns errors, FIX THEM before doing anything else. Follow the `fix_hint` in the error output.
- Type hints are mandatory on all functions
- Docstrings are mandatory on all public functions
- If a warning has `confidence` < 0.7, attempt one fix. If it doesn't resolve, move on — the resolution may be incorrect.

### If compile keeps failing (circuit breaker):
- If `keel compile` returns the same error after your fix attempt, follow keel's escalation instructions at each step:
  1. **First failure:** Fix using the `fix_hint` provided
  2. **Second failure (same error):** Run `keel discover <hash> --depth 2` as instructed — the issue may be upstream
  3. **Third failure (same error):** keel auto-downgrades to WARNING. Run `keel explain <error-code> <hash>` to inspect the resolution chain. Add findings as a code comment so the next session can resolve with full context.
- Downgraded errors re-enforce on next session — they are not permanently suppressed.

### Before creating a new function:
1. Check the keel map to see if a similar function already exists
2. Place the function in the module where it logically belongs
3. If keel warns about placement, move the function to the suggested module

### When scaffolding (creating multiple new files at once):
1. Run `keel compile --batch-start` before creating files
2. Create files normally — structural errors (broken callers) still fire immediately
3. Type hint and docstring errors are deferred until batch ends
4. Run `keel compile --batch-end` when scaffolding is complete — all deferred validations fire

### Commands:
- `keel discover <hash>` — show callers, callees, and module context
- `keel compile <file>` — validate changes
- `keel compile --batch-start` / `--batch-end` — batch mode for scaffolding sessions
- `keel explain <error-code> <hash>` — inspect resolution reasoning
- `keel where <hash>` — resolve hash to file:line
- `keel map --llm` — regenerate the LLM-optimized map
```

---

## Post-Edit Hook Script

`.keel/hooks/post-edit.sh` — committed, shared across all Tier 1 tools:

```bash
#!/bin/bash
set -euo pipefail
# .keel/hooks/post-edit.sh
INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')
[ -z "$FILE_PATH" ] && exit 0

# Validate file path — reject metacharacters that could enable argument injection
if [[ "$FILE_PATH" =~ [^a-zA-Z0-9_./-] ]]; then
  echo "keel: rejected file path with unexpected characters: $FILE_PATH" >&2
  exit 2
fi

RESULT=$(keel compile -- "$FILE_PATH" --json 2>&1)
EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
  echo "$RESULT" >&2
  exit 2  # Blocking: stderr shown to LLM, must fix before proceeding
fi
exit 0
```

---

## Pre-Commit Git Hook

`keel init` installs a pre-commit hook in `.git/hooks/pre-commit` (or adds a keel section if a pre-commit hook already exists):

```bash
#!/bin/bash
# keel pre-commit hook — safety net for cooperative tools
RESULT=$(keel compile --strict --json 2>&1)
EXIT_CODE=$?
if [ $EXIT_CODE -ne 0 ]; then
  echo "keel: commit blocked — violations found:" >&2
  echo "$RESULT" >&2
  exit 1
fi
```

This catches anything that slipped past hooks (Tier 2 tools) or was committed without running hooks.

---

## CI Templates

### GitHub Actions

`.github/workflows/keel.yml` (generated by `keel init`):

```yaml
name: keel
on: [push, pull_request]
jobs:
  keel:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install keel
        run: curl -fsSL https://keel.engineer/install.sh | sh
      - name: Validate codebase
        run: keel map --json --strict
```

The `--strict` flag exits non-zero if any `ERROR`-level violations exist. This catches anything that slipped past hooks and pre-commit.

### GitLab CI

`.gitlab-ci.yml` snippet (generated by `keel init`):

```yaml
keel:
  stage: test
  script:
    - curl -fsSL https://keel.engineer/install.sh | sh
    - keel map --json --strict
```

---

## Tool Auto-Detection

`keel init` scans the project root for the following files/directories to determine which tools are installed:

| Scan Target | Tool Detected |
|-------------|---------------|
| `.claude/` | Claude Code |
| `.cursor/` | Cursor |
| `.gemini/` or `GEMINI.md` | Gemini CLI |
| `.windsurf/` or `.windsurfrules` | Windsurf |
| Letta config file | Letta Code |
| `.codex/` | Codex CLI |
| `.agent/` | Antigravity |
| `.aider.conf.yml` | Aider |
| `.github/copilot-instructions.md` | GitHub Copilot |
| `.github/workflows/` | GitHub Actions CI |

---

## Config Merge Strategy on `init`

When `keel init` runs in a project with existing tool configurations, keel merges its entries rather than overwriting:

- **JSON files** (`.claude/settings.json`, `.cursor/hooks.json`, `.gemini/settings.json`, `.windsurf/hooks.json`): Deep-merge keel hook entries into existing hooks arrays. Warn if a conflicting hook exists for the same event/matcher.
- **Markdown files** (`CLAUDE.md`, `GEMINI.md`, `.windsurfrules`, `AGENTS.md`): Insert keel sections between `<!-- keel:start -->` / `<!-- keel:end -->` markers. If markers already exist, replace that section. If not, append to end.
- **TOML/YAML files** (`.aider.conf.yml`, `.codex/config.toml`): Add keel-specific sections. Warn on key conflicts.
- **On conflict:** keel prints a warning and skips the conflicting entry, leaving the existing config intact. The developer resolves manually.

---

## Backpressure Flow

### Tier 1 Tools (Claude Code, Cursor, Gemini CLI, Windsurf, Letta Code — enforced):

1. Developer gives task -> **SessionStart** hook injects map into context (`keel map --llm`)
2. Instruction file instructs: call `discover` before editing functions with callers
3. LLM makes an edit -> **PostToolUse** hook auto-runs `compile`
4. If errors -> hook exits code 2 -> stderr shown to LLM -> must fix before proceeding
5. LLM fixes -> `compile` passes -> continues

This is the same flow in all 5 Tier 1 tools. The hook config format varies but the mechanism is identical: exit code 2 blocks, stderr is shown to the LLM.

### Tier 2 Tools (GitHub Copilot, Codex, Antigravity, Aider — cooperative):

1. Developer gives task -> instruction file / MCP policy provides map + workflow rules
2. LLM follows instructions: calls `discover`, then edits, then runs `compile`
3. If LLM skips `compile` -> git pre-commit hook catches violations at commit time
4. If LLM skips pre-commit (force push) -> CI catches violations at build time

### Enforcement Layers (Defense in Depth):

1. **Proactive (instruction files):** LLM instructed to use `discover` before editing. Cooperative. All tools.
2. **Reactive (tool hooks):** `compile` auto-runs after every edit. **Enforced** in Tier 1 tools. Governance-level in GitHub Copilot. Not available in Codex, Antigravity, Aider.
3. **Commit gate (git pre-commit hook):** `compile --strict` blocks commit. Catches everything that slipped past hooks.
4. **Build gate (CI):** `keel map --json --strict` fails the build. Final safety net.

---

## Inter-Agent Contracts

### Exposed by this spec (Agent C -> all agents):

**Tool detection result:** Auto-detection produces a list of detected tools with their tier classification, used by `init` to decide what configs to generate.

```rust
pub struct DetectedTool {
    pub name: String,           // e.g., "claude-code", "cursor"
    pub tier: Tier,             // Tier1 or Tier2
    pub config_path: String,    // e.g., ".claude/settings.json"
    pub instruction_path: String, // e.g., "CLAUDE.md"
}

pub enum Tier { Tier1, Tier2 }
```

**Config generators:** Each tool has a dedicated config generator that produces the appropriate hook config or instruction file.

### Consumed by this spec:

- **[[keel-speckit/006-enforcement-engine/spec|Spec 006]]** — enforcement engine provides `compile` behavior triggered by hooks
- **[[keel-speckit/008-output-formats/spec|Spec 008]]** — JSON output consumed by hooks to determine exit code

---

## Acceptance Criteria

**GIVEN** a project with Claude Code installed (`.claude/` directory exists)
**WHEN** `keel init` is run
**THEN** `.claude/settings.json` is generated with SessionStart and PostToolUse hooks, `CLAUDE.md` has keel instructions appended between markers, and `.keel/hooks/post-edit.sh` is executable.

**GIVEN** a project with Cursor and Gemini CLI detected
**WHEN** `keel init` is run
**THEN** `.cursor/hooks.json`, `.cursor/rules/keel.mdc`, `.gemini/settings.json`, and `GEMINI.md` are all generated with correct hook configurations.

**GIVEN** a project with an existing `.claude/settings.json` containing user-defined hooks
**WHEN** `keel init` is run
**THEN** keel's hook entries are deep-merged alongside existing hooks without overwriting them.

**GIVEN** a project with existing `CLAUDE.md` content
**WHEN** `keel init` is run
**THEN** keel instructions are inserted between `<!-- keel:start -->` / `<!-- keel:end -->` markers without modifying existing content outside those markers.

**GIVEN** a Tier 1 tool (e.g., Claude Code) makes a file edit that introduces a broken caller
**WHEN** the PostToolUse hook fires
**THEN** `keel compile` runs, detects the E001 error, the hook exits with code 2, and the error with `fix_hint` is shown to the LLM via stderr.

**GIVEN** a project with Windsurf detected
**WHEN** `keel init` generates `.windsurf/hooks.json`
**THEN** the hook uses `PreToolUse` (not `PostToolUse`) as the event name, matching Windsurf's hook semantics.

**GIVEN** a project with Aider detected
**WHEN** `keel init` generates `.aider.conf.yml`
**THEN** the config uses `map-tokens` and `map-refresh` keys (NOT `map-file`).

**GIVEN** a project with no tool directories detected
**WHEN** `keel init` is run
**THEN** no hook configs are generated, but the pre-commit hook and `.keel/` directory are still created. A warning is emitted that no LLM tools were detected.

**GIVEN** a CI directory `.github/workflows/` exists
**WHEN** `keel init` is run
**THEN** a GitHub Actions workflow file for keel is generated.

**GIVEN** an initialized project
**WHEN** `keel deinit` is run
**THEN** all keel hook entries are removed from tool configs, keel sections are removed from instruction files, and tool configs remain valid after removal.

---

## Test Strategy

**Oracle:** Template generation correctness and hook behavior.
- Verify each tool's config file is valid after generation (JSON parse, YAML parse, markdown structure).
- Verify hook configs trigger the correct keel commands.
- Verify config merge produces valid output with pre-existing configs.
- Verify deinit cleanly removes all keel additions.

**Test files to create:**
- `tests/integration/test_claude_code_config.rs` (~5 tests)
- `tests/integration/test_cursor_config.rs` (~5 tests)
- `tests/integration/test_gemini_config.rs` (~5 tests)
- `tests/integration/test_windsurf_config.rs` (~4 tests)
- `tests/integration/test_letta_config.rs` (~3 tests)
- `tests/integration/test_codex_config.rs` (~3 tests)
- `tests/integration/test_antigravity_config.rs` (~3 tests)
- `tests/integration/test_aider_config.rs` (~3 tests)
- `tests/integration/test_copilot_config.rs` (~3 tests)
- `tests/integration/test_config_merge.rs` (~6 tests)
- `tests/integration/test_auto_detection.rs` (~5 tests)
- `tests/integration/test_deinit_cleanup.rs` (~4 tests)

**Estimated test count:** ~49

---

## Known Risks

| Risk | Mitigation |
|------|-----------|
| Tool hook formats change in future versions | Pin to known-working formats. Monitor tool changelogs. Version detection for format differences. |
| Cursor v2.0+ ignores `agent_message` in hook responses | Workaround: write error context to `.keel/last-error.json`, instruct agent to read it via `.cursor/rules/keel.mdc`. |
| Config merge produces invalid JSON | Validate merged JSON before writing. On validation failure, warn and write keel-only config to a separate file. |
| Aider adds/removes config keys in future versions | Use only documented, stable Aider config keys (`map-tokens`, `map-refresh`). |
| Letta config format not yet stable | Abstract Letta config generation behind an adapter. Update when Letta stabilizes. |

---

## Related Specs

- [[keel-speckit/006-enforcement-engine/spec|Spec 006: Enforcement Engine]] — enforcement logic triggered by hooks
- [[keel-speckit/007-cli-commands/spec|Spec 007: CLI Commands]] — commands invoked by hooks and instructions
- [[keel-speckit/008-output-formats/spec|Spec 008: Output Formats]] — JSON output consumed by hooks
- [[keel-speckit/010-mcp-http-server/spec|Spec 010: MCP/HTTP Server]] — MCP server integration referenced by Copilot and MCP-capable tools
- [[keel-speckit/011-vscode-extension/spec|Spec 011: VS Code Extension]] — extension consumes server output
- [[keel-speckit/012-distribution/spec|Spec 012: Distribution]] — install scripts referenced in CI templates
