// Tests for Rust macro resolution (Spec 005 - Rust Resolution)
//
// Macro resolution at the parser layer is limited. tree-sitter can capture
// macro invocations as references but cannot resolve them to their definitions
// without understanding macro expansion (a Tier 2/3 feature).

use std::path::Path;

use keel_parsers::resolver::LanguageResolver;
use keel_parsers::rust_lang::RustLangResolver;

#[test]
/// macro_rules! definitions should be extracted by tree-sitter.
fn test_macro_rules_definition_extraction() {
    let resolver = RustLangResolver::new();
    let source = r#"
macro_rules! my_vec {
    ($($x:expr),*) => {
        {
            let mut v = Vec::new();
            $(v.push($x);)*
            v
        }
    };
}

fn main() {
    let v = my_vec![1, 2, 3];
}
"#;
    let result = resolver.parse_file(Path::new("macros.rs"), source);

    // tree-sitter should capture the macro_rules definition
    let macro_def = result.definitions.iter().find(|d| d.name == "my_vec");
    if macro_def.is_some() {
        // If captured, verify the name
        assert_eq!(macro_def.unwrap().name, "my_vec");
    }
    // At minimum, parsing should succeed and capture the function
    let main_fn = result.definitions.iter().find(|d| d.name == "main");
    assert!(main_fn.is_some(), "should find main() function");
}

#[test]
/// Functions with derive macros should still be parsed correctly.
fn test_derive_macro_struct_extraction() {
    let resolver = RustLangResolver::new();
    let source = r#"
#[derive(Debug, Clone)]
pub struct Config {
    name: String,
    value: i32,
}
"#;
    let result = resolver.parse_file(Path::new("config.rs"), source);

    let struct_def = result.definitions.iter().find(|d| d.name == "Config");
    assert!(struct_def.is_some(), "should find Config struct despite derive macros");
    assert!(
        struct_def.unwrap().is_public,
        "pub struct with derive should be public"
    );
}

#[test]
#[ignore = "BUG: macro invocation to definition resolution requires macro expansion"]
/// Declarative macro invocations (macro_rules!) should be tracked as call edges.
fn test_macro_rules_invocation_resolution() {
    // Linking my_macro!() to the macro_rules! definition requires
    // understanding macro expansion, which is beyond tree-sitter.
}

#[test]
#[ignore = "BUG: derive macro resolution requires proc-macro crate analysis"]
/// Derive macro usage should create edges to the derive macro definition.
fn test_derive_macro_resolution() {
    // #[derive(Serialize)] requires resolving to the serde_derive proc
    // macro crate, which is beyond parser scope.
}

#[test]
#[ignore = "BUG: attribute macro resolution requires proc-macro analysis"]
/// Attribute macro resolution should link to the proc macro function.
fn test_attribute_macro_resolution() {
    // #[tokio::main] requires resolving to the tokio proc macro, which
    // is beyond parser scope.
}

#[test]
#[ignore = "BUG: macro-generated code confidence scoring not implemented"]
/// Code generated by macros should have lower confidence in resolution.
fn test_macro_generated_code_confidence() {
    // Detecting that code was generated by a macro expansion and adjusting
    // confidence accordingly requires macro expansion tracking.
}
