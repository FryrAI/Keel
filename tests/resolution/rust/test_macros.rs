// Tests for Rust macro resolution (Spec 005 - Rust Resolution)
//
// Tier 2 heuristic: tree-sitter captures macro_rules! definitions and
// macro invocations. resolve_call_edge matches `name!()` to `macro_rules! name`.

use std::path::Path;

use keel_parsers::resolver::{CallSite, LanguageResolver};
use keel_parsers::rust_lang::RustLangResolver;

#[test]
/// macro_rules! definitions should be extracted by tree-sitter.
fn test_macro_rules_definition_extraction() {
    let resolver = RustLangResolver::new();
    let source = r#"
macro_rules! my_vec {
    ($($x:expr),*) => {
        {
            let mut v = Vec::new();
            $(v.push($x);)*
            v
        }
    };
}

fn main() {
    let v = my_vec![1, 2, 3];
}
"#;
    let result = resolver.parse_file(Path::new("macros.rs"), source);

    // tree-sitter should capture the macro_rules definition
    let macro_def = result.definitions.iter().find(|d| d.name == "my_vec");
    assert!(
        macro_def.is_some(),
        "should find my_vec macro definition, got: {:?}",
        result.definitions.iter().map(|d| &d.name).collect::<Vec<_>>()
    );
    // At minimum, parsing should succeed and capture the function
    let main_fn = result.definitions.iter().find(|d| d.name == "main");
    assert!(main_fn.is_some(), "should find main() function");
}

#[test]
/// Functions with derive macros should still be parsed correctly.
fn test_derive_macro_struct_extraction() {
    let resolver = RustLangResolver::new();
    let source = r#"
#[derive(Debug, Clone)]
pub struct Config {
    name: String,
    value: i32,
}
"#;
    let result = resolver.parse_file(Path::new("config.rs"), source);

    let struct_def = result.definitions.iter().find(|d| d.name == "Config");
    assert!(struct_def.is_some(), "should find Config struct despite derive macros");
    assert!(
        struct_def.unwrap().is_public,
        "pub struct with derive should be public"
    );
}

#[test]
/// Declarative macro invocations (macro_rules!) should be tracked as call edges.
/// Tier 2 heuristic: strip `!` from invocation, match to same-file definition.
fn test_macro_rules_invocation_resolution() {
    let resolver = RustLangResolver::new();
    let source = r#"
macro_rules! my_vec {
    ($($x:expr),*) => {
        {
            let mut v = Vec::new();
            $(v.push($x);)*
            v
        }
    };
}

fn main() {
    let v = my_vec![1, 2, 3];
}
"#;
    let path = Path::new("macros.rs");
    resolver.parse_file(path, source);

    // The reference for `my_vec!` should be captured with "!" suffix
    let refs = resolver.resolve_references(path);
    let macro_ref = refs.iter().find(|r| r.name.contains("my_vec"));
    assert!(
        macro_ref.is_some(),
        "should capture my_vec! invocation as reference, got: {:?}",
        refs.iter().map(|r| &r.name).collect::<Vec<_>>()
    );

    // resolve_call_edge should match my_vec! to the macro_rules! definition
    let edge = resolver.resolve_call_edge(&CallSite {
        file_path: "macros.rs".into(),
        line: 13,
        callee_name: "my_vec!".into(),
        receiver: None,
    });
    assert!(edge.is_some(), "should resolve my_vec! to macro definition");
    let edge = edge.unwrap();
    assert_eq!(edge.target_name, "my_vec");
    assert_eq!(edge.target_file, "macros.rs");
    // Same-file macro: confidence 0.60
    assert!(
        (edge.confidence - 0.60).abs() < 0.01,
        "same-file macro confidence should be 0.60, got {}",
        edge.confidence
    );
    assert_eq!(edge.resolution_tier, "tier2");
}

#[test]
/// Derive macro usage should create references for each derive name.
fn test_derive_macro_resolution() {
    let resolver = RustLangResolver::new();
    let source = r#"
#[derive(Debug, Clone)]
pub struct Config {
    name: String,
}
"#;
    let path = Path::new("derive.rs");
    resolver.parse_file(path, source);
    let refs = resolver.resolve_references(path);
    let debug_ref = refs.iter().find(|r| r.name == "Debug");
    assert!(debug_ref.is_some(),
        "should capture Debug derive as reference, got: {:?}",
        refs.iter().map(|r| &r.name).collect::<Vec<_>>());
    let clone_ref = refs.iter().find(|r| r.name == "Clone");
    assert!(clone_ref.is_some(), "should capture Clone derive as reference");
}

#[test]
/// Attribute macro resolution should capture path-based attribute macros as references.
fn test_attribute_macro_resolution() {
    let resolver = RustLangResolver::new();
    let source = r#"
#[tokio::main]
async fn main() {
    println!("hello");
}
"#;
    let path = Path::new("attr_macro.rs");
    resolver.parse_file(path, source);
    let refs = resolver.resolve_references(path);
    let tokio_ref = refs.iter().find(|r| r.name == "tokio::main");
    assert!(tokio_ref.is_some(),
        "should capture tokio::main attribute macro as reference, got: {:?}",
        refs.iter().map(|r| &r.name).collect::<Vec<_>>());
}

#[test]
/// Code generated by macros should have lower confidence in resolution.
/// Tier 2 heuristic: definitions found inside macro_rules body get lower
/// confidence when resolved, because they are macro-generated.
fn test_macro_generated_code_confidence() {
    let resolver = RustLangResolver::new();
    // Source where a macro_rules! definition exists alongside a normal function.
    // The macro itself is a definition; resolving a call to it yields confidence
    // 0.60 (lower than the 0.95 for same-file normal functions).
    let source = r#"
macro_rules! define_helper {
    () => {
        fn generated_helper() -> i32 { 42 }
    };
}

fn normal_func() -> i32 { 1 }

fn main() {
    normal_func();
    define_helper!();
}
"#;
    let path = Path::new("gen.rs");
    resolver.parse_file(path, source);

    // Normal function: high confidence (0.95)
    let normal_edge = resolver.resolve_call_edge(&CallSite {
        file_path: "gen.rs".into(),
        line: 11,
        callee_name: "normal_func".into(),
        receiver: None,
    });
    assert!(normal_edge.is_some(), "should resolve normal_func");
    let normal_conf = normal_edge.unwrap().confidence;

    // Macro invocation: lower confidence (0.60)
    let macro_edge = resolver.resolve_call_edge(&CallSite {
        file_path: "gen.rs".into(),
        line: 12,
        callee_name: "define_helper!".into(),
        receiver: None,
    });
    assert!(macro_edge.is_some(), "should resolve define_helper! macro");
    let macro_conf = macro_edge.unwrap().confidence;

    assert!(
        macro_conf < normal_conf,
        "macro-generated code confidence ({}) should be lower than normal ({})",
        macro_conf,
        normal_conf
    );
}
